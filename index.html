<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>POCKET FIREWORK: Mobile</title>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-blue: #00f3ff;
            --neon-pink: #ff00ff;
            --bg-color: #000000;
            /* KPOP 2025 Color Palette */
            --kpop-purple: #D946EF;
            --kpop-purple-light: #A855F7;
            --kpop-pink: #EC4899;
            --kpop-pink-light: #F472B6;
            --kpop-blue: #06B6D4;
            --kpop-blue-bright: #3B82F6;
            --kpop-gradient-1: linear-gradient(135deg, #D946EF, #EC4899, #06B6D4);
            --kpop-gradient-2: linear-gradient(135deg, #A855F7, #F472B6, #3B82F6);
            --kpop-gradient-3: linear-gradient(135deg, #EC4899, #D946EF, #3B82F6);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            overflow: hidden;
            font-family: 'Rajdhani', sans-serif;
            color: white;
            height: 100vh;
            width: 100vw;
            touch-action: none; /* Disables browser zooming/scrolling */
            -webkit-user-select: none; /* Safari select disable */
            user-select: none;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            will-change: transform;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        /* --- UI Layers --- */

        /* Splash Screen */
        #splash-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 50;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #0a0a0f;
            background-image: 
                radial-gradient(circle at 20% 50%, rgba(217, 70, 239, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(236, 72, 153, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 50% 20%, rgba(6, 182, 212, 0.15) 0%, transparent 50%);
            animation: gradientShift 8s ease infinite;
            backdrop-filter: blur(2px);
            transition: opacity 0.6s ease;
            overflow: hidden;
        }

        #splash-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(217, 70, 239, 0.1), rgba(236, 72, 153, 0.1), rgba(6, 182, 212, 0.1));
            background-size: 200% 200%;
            animation: gradientRotate 10s ease infinite;
            pointer-events: none;
        }

        h1 {
            font-size: 3rem;
            margin: 0 0 10px 0;
            text-transform: uppercase;
            letter-spacing: 5px;
            background: linear-gradient(90deg, #D946EF, #EC4899, #06B6D4, #3B82F6, #D946EF);
            background-size: 300% 100%;
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-align: center;
            animation: textShimmer 3s ease infinite, pulseGlow 2s ease-in-out infinite;
            position: relative;
            z-index: 1;
            will-change: background-position, filter;
        }

        p.subtitle {
            font-size: 1rem;
            background: linear-gradient(90deg, #F472B6, #A855F7, #F472B6);
            background-size: 200% 100%;
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 40px;
            text-transform: uppercase;
            letter-spacing: 2px;
            animation: textShimmer 4s ease infinite;
            opacity: 0.9;
            position: relative;
            z-index: 1;
        }

        button.start-btn {
            background: linear-gradient(135deg, #D946EF, #EC4899, #06B6D4, #3B82F6);
            background-size: 300% 300%;
            color: #ffffff;
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.2rem;
            font-weight: 700;
            letter-spacing: 3px;
            padding: 15px 40px;
            border: 2px solid transparent;
            border-radius: 30px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 
                0 0 30px rgba(217, 70, 239, 0.6),
                0 0 60px rgba(236, 72, 153, 0.4),
                0 4px 20px rgba(0, 0, 0, 0.3),
                inset 0 0 20px rgba(255, 255, 255, 0.1);
            animation: gradientRotate 4s ease infinite, buttonGlow 2s ease-in-out infinite;
            transition: transform 0.2s ease, box-shadow 0.3s ease;
            position: relative;
            z-index: 1;
            overflow: hidden;
            will-change: transform, background-position;
        }

        button.start-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }

        button.start-btn:hover {
            transform: scale(1.05);
            box-shadow: 
                0 0 40px rgba(217, 70, 239, 0.8),
                0 0 80px rgba(236, 72, 153, 0.6),
                0 6px 30px rgba(0, 0, 0, 0.4),
                inset 0 0 30px rgba(255, 255, 255, 0.2);
        }

        button.start-btn:hover::before {
            left: 100%;
        }

        button.start-btn:active {
            transform: scale(0.98);
            animation: gradientRotate 4s ease infinite, buttonGlow 2s ease-in-out infinite, buttonPress 0.2s ease;
        }

        /* Mobile Controls (Bottom Bar) */
        #controls {
            position: absolute;
            bottom: max(30px, env(safe-area-inset-bottom, 30px)); /* Better safe area handling */
            left: 0;
            width: 100%;
            z-index: 20;
            display: flex;
            justify-content: center; /* Center the 2 buttons */
            gap: 40px; /* Space between buttons */
            padding: 0 20px;
            box-sizing: border-box;
            pointer-events: none; /* Let touches pass through gaps */
            opacity: 0;
            transition: opacity 1s ease;
        }

        .control-btn {
            pointer-events: auto;
            width: clamp(70px, 12vw, 90px); /* Responsive sizing */
            height: clamp(70px, 12vw, 90px);
            min-width: 70px; /* Ensure minimum touch target */
            min-height: 70px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.4); /* Thicker border for visibility */
            background: rgba(0, 0, 0, 0.7); /* More opaque for better visibility */
            backdrop-filter: blur(8px);
            color: white;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 700;
            font-size: clamp(0.75rem, 2.5vw, 0.9rem); /* Responsive font */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            touch-action: manipulation;
            transition: transform 0.15s, border-color 0.2s, box-shadow 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); /* Better depth */
        }

        .control-btn:active, .control-btn.active {
            transform: scale(0.9); /* More pronounced press */
            background: rgba(255, 255, 255, 0.15);
        }

        #btn-mode.mode-attract { 
            border-color: var(--neon-blue); 
            color: var(--neon-blue); 
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.4), 0 4px 12px rgba(0, 0, 0, 0.3); 
        }
        #btn-mode.mode-repel { 
            border-color: var(--neon-pink); 
            color: var(--neon-pink); 
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.4), 0 4px 12px rgba(0, 0, 0, 0.3); 
        }
        
        #btn-slow { 
            border-color: #ffd700; 
            color: #ffd700; 
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3), 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        #btn-slow:active, #btn-slow.active { 
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.6), 0 4px 12px rgba(0, 0, 0, 0.3); 
        }

        .hidden { opacity: 0 !important; pointer-events: none !important; }
        .fade-in { opacity: 1 !important; }

        /* Instructions Overlay */
        #top-msg {
            position: absolute;
            top: max(20px, env(safe-area-inset-top, 20px));
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.7); /* More visible */
            font-size: clamp(0.7rem, 2vw, 0.9rem); /* Responsive */
            pointer-events: none;
            z-index: 10;
            letter-spacing: 2px;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8), 0 0 4px rgba(0, 0, 0, 0.5); /* Better shadow */
            padding: 0 20px;
            box-sizing: border-box;
            line-height: 1.4;
        }

        /* Settings Panel */
        #settings-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 30;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        #settings-panel.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #btn-settings {
            width: clamp(50px, 10vw, 60px);
            height: clamp(50px, 10vw, 60px);
            min-width: 50px;
            min-height: 50px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.4);
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            color: white;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 700;
            font-size: clamp(1.2rem, 4vw, 1.5rem);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            touch-action: manipulation;
            pointer-events: auto !important;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: transform 0.15s;
        }
        
        #btn-settings:active {
            transform: scale(0.9);
        }

        #settings-menu {
            position: absolute;
            top: 70px;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 20px;
            min-width: 250px;
            max-width: 90vw;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
        }

        #settings-menu.visible {
            display: block;
        }

        .settings-section {
            margin-bottom: 20px;
        }

        .settings-section h3 {
            font-size: 0.9rem;
            margin: 0 0 10px 0;
            color: var(--neon-blue);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .color-scheme-btn {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            margin: 5px;
            cursor: pointer;
            display: inline-block;
            transition: transform 0.2s, border-color 0.2s;
        }

        .color-scheme-btn.active {
            border-color: var(--neon-blue);
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.5);
        }

        .slider-container {
            margin: 10px 0;
        }

        .slider-label {
            font-size: 0.8rem;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--neon-blue);
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--neon-blue);
            cursor: pointer;
            border: none;
        }

        .preset-btn {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: white;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 700;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: background 0.2s, border-color 0.2s;
        }

        .preset-btn:hover, .preset-btn:active {
            background: rgba(0, 243, 255, 0.2);
            border-color: var(--neon-blue);
        }

        /* Performance Metrics */
        #performance {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.7rem;
            font-family: 'Rajdhani', monospace;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #performance.visible {
            opacity: 1;
        }

        /* KPOP-Inspired Animations */
        @keyframes gradientShift {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }

        @keyframes gradientRotate {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }

        @keyframes textShimmer {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }

        @keyframes pulseGlow {
            0%, 100% {
                filter: drop-shadow(0 0 10px rgba(217, 70, 239, 0.6)) 
                        drop-shadow(0 0 20px rgba(236, 72, 153, 0.4)) 
                        drop-shadow(0 0 30px rgba(6, 182, 212, 0.3));
            }
            50% {
                filter: brightness(1.1) drop-shadow(0 0 15px rgba(217, 70, 239, 0.8)) 
                        drop-shadow(0 0 30px rgba(236, 72, 153, 0.6)) 
                        drop-shadow(0 0 45px rgba(6, 182, 212, 0.5));
            }
        }

        @keyframes buttonPress {
            0% {
                transform: scale(1.05);
            }
            50% {
                transform: scale(0.95);
            }
            100% {
                transform: scale(1);
            }
        }

        @keyframes buttonGlow {
            0%, 100% {
                box-shadow: 
                    0 0 30px rgba(217, 70, 239, 0.6),
                    0 0 60px rgba(236, 72, 153, 0.4),
                    0 4px 20px rgba(0, 0, 0, 0.3),
                    inset 0 0 20px rgba(255, 255, 255, 0.1);
            }
            50% {
                box-shadow: 
                    0 0 40px rgba(217, 70, 239, 0.8),
                    0 0 80px rgba(236, 72, 153, 0.6),
                    0 6px 30px rgba(0, 0, 0, 0.4),
                    inset 0 0 30px rgba(255, 255, 255, 0.15);
            }
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-20px);
            }
        }

    </style>
</head>
<body>

    <div id="top-msg" class="hidden">
        <div style="margin-bottom: 4px;">DRAG TO ATTRACT</div>
        <div style="font-size: 0.85em; opacity: 0.8;">TAP TO EXPLODE</div>
    </div>

    <div id="performance" class="hidden">
        <div>FPS: <span id="fps">0</span></div>
        <div>Particles: <span id="particle-count">0</span></div>
    </div>

    <div id="settings-panel" class="hidden">
        <div id="btn-settings" onclick="toggleSettings()">‚öô</div>
        <div id="settings-menu">
            <div class="settings-section">
                <h3>Color Scheme</h3>
                <div id="color-schemes">
                    <div class="color-scheme-btn active" data-scheme="neon" style="background: linear-gradient(135deg, #00f3ff, #ff00ff);" onclick="setColorScheme('neon')" title="Neon"></div>
                    <div class="color-scheme-btn" data-scheme="fire" style="background: linear-gradient(135deg, #ff6b6b, #ffd93d);" onclick="setColorScheme('fire')" title="Fire"></div>
                    <div class="color-scheme-btn" data-scheme="ocean" style="background: linear-gradient(135deg, #4ecdc4, #44a3ff);" onclick="setColorScheme('ocean')" title="Ocean"></div>
                    <div class="color-scheme-btn" data-scheme="purple" style="background: linear-gradient(135deg, #667eea, #764ba2);" onclick="setColorScheme('purple')" title="Purple"></div>
                    <div class="color-scheme-btn" data-scheme="pink" style="background: linear-gradient(135deg, #f093fb, #f5576c);" onclick="setColorScheme('pink')" title="Pink"></div>
                    <div class="color-scheme-btn" data-scheme="cyan" style="background: linear-gradient(135deg, #4facfe, #00f2fe);" onclick="setColorScheme('cyan')" title="Cyan"></div>
                </div>
            </div>
            <div class="settings-section">
                <h3>Particle Count</h3>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Density</span>
                        <span id="particle-count-display">1800</span>
                    </div>
                    <input type="range" id="particle-slider" min="400" max="8000" step="50" oninput="updateParticleCount(this.value)">
                </div>
            </div>
            <div class="settings-section">
                <h3>Preset Patterns</h3>
                <button class="preset-btn" onclick="applyPattern('vortex')">üåÄ Vortex</button>
                <button class="preset-btn" onclick="applyPattern('spiral')">üå™Ô∏è Spiral</button>
                <button class="preset-btn" onclick="applyPattern('explosion')">üí• Explosion</button>
                <button class="preset-btn" onclick="applyPattern('orbit')">üåç Orbit</button>
                <button class="preset-btn" onclick="applyPattern('wave')">üåä Wave</button>
            </div>
            <div class="settings-section">
                <h3>Show Performance</h3>
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="show-performance" onchange="togglePerformance(this.checked)" style="margin-right: 10px;">
                    <span>Display FPS & Stats</span>
                </label>
            </div>
        </div>
    </div>

    <div id="controls" class="hidden">
        <!-- Gravity Toggle -->
        <div id="btn-mode" class="control-btn mode-attract" onclick="toggleMode()">
            <span>Mode</span>
            <span id="mode-label" style="font-size:0.7rem">Gravity</span>
        </div>

        <!-- Time Dilation (Hold) -->
        <div id="btn-slow" class="control-btn" 
             ontouchstart="setSlow(true)" 
             ontouchend="setSlow(false)"
             onmousedown="setSlow(true)"
             onmouseup="setSlow(false)">
            <span>Slow</span>
            <span style="font-size:0.7rem">Motion</span>
        </div>
    </div>

    <!-- Phase 1: Tap Instruction -->
    <div id="tap-instruction" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: rgba(255, 255, 255, 0.5); font-family: 'Rajdhani', sans-serif; font-size: clamp(0.9rem, 3vw, 1.2rem); letter-spacing: 3px; text-transform: uppercase; z-index: 15; pointer-events: none; transition: opacity 0.5s ease;">
        tap
    </div>

    <!-- Phase 2: Tap Again Instruction (centered in heart) -->
    <div id="tap-again-instruction" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: rgba(255, 255, 255, 0.5); font-family: 'Rajdhani', sans-serif; font-size: clamp(0.85rem, 2.8vw, 1.1rem); letter-spacing: 3px; text-transform: uppercase; z-index: 15; pointer-events: none; opacity: 0; transition: opacity 0.8s ease;">
        tap again
    </div>
    
    <canvas id="canvas"></canvas>

<script>
/**
 * MOBILE CONFIGURATION
 */
const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

const config = {
    // Optimized particle counts for smooth performance
    particleCount: isMobile ? 600 : 3500, // Further reduced for better performance and cleaner look
    baseSpeed: isMobile ? 1.2 : 1.5,
    friction: 0.95,
    gravityStrength: isMobile ? 0.9 : 0.85, // Slightly stronger on mobile for better feel
    shockwaveForce: isMobile ? 60 : 55, // More pronounced on mobile
    colorSpeed: 0.8, // Increased for more vibrant color cycling 
    trailLength: isMobile ? 0.06 : 0.15, // Further reduced on mobile for cleaner look
    targetFPS: isMobile ? 60 : 120,
    adaptiveQuality: isMobile ? true : false,
    minParticleCount: isMobile ? 400 : 2000,
    maxParticleCount: isMobile ? 900 : 5000
};

const state = {
    mouseX: window.innerWidth / 2,
    mouseY: window.innerHeight / 2,
    isTouching: false, // For tracking if user is touching canvas
    gravityMode: 1, // 1 = Attract, -1 = Repel
    isSlowMo: false,
    hue: 200,
    gameStarted: false,
    autoTimer: 0,
    colorScheme: 'neon',
    showPerformance: false,
    fps: 0,
    frameCount: 0,
    lastTime: performance.now(),
    lastFrameTime: performance.now(),
    frameDelta: 0,
    targetFrameTime: 1000 / 60, // 60fps default
    adaptiveQualityCounter: 0,
    consecutiveLowFPS: 0,
    consecutiveHighFPS: 0,
    textBurst: false, // Tracks if text has been burst by user interaction
    // Phase management
    tapCount: 0, // 0 = initial, 1 = heart formed, 2 = text revealed, 3 = particles dispersed
    heartForming: false, // Animation in progress
    heartFormed: false, // Heart formation complete
    heartAnimationStart: 0, // Timestamp when heart animation started
    heartAnimationDuration: isMobile ? 2000 : 2500, // Longer duration for grander effect: 2-2.5s
    textForming: false, // Text formation animation in progress
    textFormed: false, // Text formation complete
    textAnimationStart: 0, // Timestamp when text animation started
    textAnimationDuration: isMobile ? 2000 : 2500, // Simple text formation: 2-2.5s
    heartParticleIndices: [], // Track which particles are part of heart outline
    textParticleIndices: [], // Track which particles form text
    particlesCirculating: false, // Deprecated - removed circulation feature
    circulationAngle: 0 // Deprecated - removed circulation feature
};

/**
 * SETUP
 */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false, willReadFrequently: false }); // Performance optimizations
ctx.imageSmoothingEnabled = false; // Disable smoothing for better performance
let width, height;
const dpr = window.devicePixelRatio || 1; // Device pixel ratio for crisp rendering

function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    // Scale canvas for HD rendering on Retina displays
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    ctx.scale(dpr, dpr); // Scale context to match device pixel ratio
    ctx.imageSmoothingEnabled = false; // Re-apply after scaling
    
    if(!state.gameStarted) {
        state.mouseX = width/2;
        state.mouseY = height/2;
    }
}
window.addEventListener('resize', resize);
resize();

// Set target frame time based on config
state.targetFrameTime = 1000 / config.targetFPS;

/**
 * INTERACTION HANDLERS (Touch & Mouse Unified)
 */

// 1. Canvas Touch Interaction
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    
    // Phase 1: First tap triggers heart formation
    if (state.tapCount === 0) {
        startHeartFormation();
        if (navigator.vibrate && isMobile) {
            navigator.vibrate(20); // Subtle tap feedback
        }
        return;
    }
    
    // Phase 2: Second tap triggers text reveal
    if (state.tapCount === 1 && state.heartFormed && !state.textForming && !state.textFormed) {
        startTextFormation();
        if (navigator.vibrate && isMobile) {
            navigator.vibrate(20); // Subtle tap feedback
        }
        return;
    }
    
    // Phase 3: Third tap on text disperses particles and activates interactive mode
    if (state.tapCount === 2 && state.textFormed && !state.textBurst) {
        // Check if tap is within text bounds
        const tapX = e.touches ? e.touches[0].clientX : e.clientX;
        const tapY = e.touches ? e.touches[0].clientY : e.clientY;
        
        if (state.textBounds && 
            tapX >= state.textBounds.minX && tapX <= state.textBounds.maxX &&
            tapY >= state.textBounds.minY && tapY <= state.textBounds.maxY) {
            
            state.textBurst = true;
            state.tapCount = 3;
            state.gameStarted = true;
            
            // Hide tap again instruction if still visible
            const tapAgainInstruction = document.getElementById('tap-again-instruction');
            if (tapAgainInstruction) {
                tapAgainInstruction.style.opacity = '0';
            }
            
            // Create stunning dispersal - particles burst outward from text
            particles.forEach((p, i) => {
                if (state.textParticleIndices.includes(i)) {
                    // Text particles burst from their text positions
                    const dx = p.x - state.textBounds.centerX;
                    const dy = p.y - state.textBounds.centerY;
                    const angle = Math.atan2(dy, dx);
                    const force = Math.random() * 8 + 4;
                    
                    p.vx = Math.cos(angle) * force + (Math.random() - 0.5) * 2;
                    p.vy = Math.sin(angle) * force + (Math.random() - 0.5) * 2;
                    
                    // Add rotation/spiral effect for fanciful dispersal
                    const spiralForce = Math.random() * 3;
                    p.vx += -Math.sin(angle) * spiralForce;
                    p.vy += Math.cos(angle) * spiralForce;
                } else if (p.isHeartParticle) {
                    // Heart particles also burst out
                    const dx = p.x - width / 2;
                    const dy = p.y - height / 2;
                    const angle = Math.atan2(dy, dx);
                    const force = Math.random() * 6 + 3;
                    
                    p.vx = Math.cos(angle) * force + (Math.random() - 0.5) * 2;
                    p.vy = Math.sin(angle) * force + (Math.random() - 0.5) * 2;
                }
            });
            
            // Show UI elements
            document.getElementById('controls').classList.add('fade-in');
            document.getElementById('top-msg').classList.add('fade-in');
            const settingsPanel = document.getElementById('settings-panel');
            settingsPanel.classList.remove('hidden');
            settingsPanel.classList.add('fade-in');
            settingsPanel.classList.add('visible');
            
            if (navigator.vibrate && isMobile) {
                navigator.vibrate(50); // Strong feedback for phase transition
            }
            return;
        }
    }
    
    if (!state.gameStarted) return;
    
    // Update position immediately
    state.mouseX = e.touches[0].clientX;
    state.mouseY = e.touches[0].clientY;
    state.isTouching = true;

    // Burst text if it hasn't been burst yet
    if (!state.textBurst) {
        state.textBurst = true;
        createShockwave(state.mouseX, state.mouseY, 2.5); // Strong burst to scatter particles
    } else {
        // Visual feedback - create shockwave on tap
        createShockwave(state.mouseX, state.mouseY, 1.2); // Slightly stronger on mobile
    }
    
    // Haptic feedback if available
    if (navigator.vibrate && isMobile) {
        navigator.vibrate(10); // Subtle tap feedback
    }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
    if (!state.gameStarted) return;
    e.preventDefault(); // Prevent scrolling
    state.mouseX = e.touches[0].clientX;
    state.mouseY = e.touches[0].clientY;
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
    state.isTouching = false;
});

// 2. Mouse Interaction (Fallback for desktop)
canvas.addEventListener('mousemove', e => {
    if (state.gameStarted) {
        state.mouseX = e.clientX;
        state.mouseY = e.clientY;
    }
});
canvas.addEventListener('mousedown', e => {
    // Phase 1: First tap triggers heart formation
    if (state.tapCount === 0) {
        startHeartFormation();
        return;
    }
    
    // Phase 2: Second tap triggers text reveal
    if (state.tapCount === 1 && state.heartFormed && !state.textForming && !state.textFormed) {
        startTextFormation();
        return;
    }
    
    // Phase 3: Third tap on text disperses particles and activates interactive mode
    if (state.tapCount === 2 && state.textFormed && !state.textBurst) {
        // Check if click is within text bounds
        const tapX = e.clientX;
        const tapY = e.clientY;
        
        if (state.textBounds && 
            tapX >= state.textBounds.minX && tapX <= state.textBounds.maxX &&
            tapY >= state.textBounds.minY && tapY <= state.textBounds.maxY) {
            
            state.textBurst = true;
            state.tapCount = 3;
            state.gameStarted = true;
            
            // Hide tap again instruction if still visible
            const tapAgainInstruction = document.getElementById('tap-again-instruction');
            if (tapAgainInstruction) {
                tapAgainInstruction.style.opacity = '0';
            }
            
            // Create stunning dispersal - particles burst outward from text
            particles.forEach((p, i) => {
                if (state.textParticleIndices.includes(i)) {
                    // Text particles burst from their text positions
                    const dx = p.x - state.textBounds.centerX;
                    const dy = p.y - state.textBounds.centerY;
                    const angle = Math.atan2(dy, dx);
                    const force = Math.random() * 8 + 4;
                    
                    p.vx = Math.cos(angle) * force + (Math.random() - 0.5) * 2;
                    p.vy = Math.sin(angle) * force + (Math.random() - 0.5) * 2;
                    
                    // Add rotation/spiral effect for fanciful dispersal
                    const spiralForce = Math.random() * 3;
                    p.vx += -Math.sin(angle) * spiralForce;
                    p.vy += Math.cos(angle) * spiralForce;
                } else if (p.isHeartParticle) {
                    // Heart particles also burst out
                    const dx = p.x - width / 2;
                    const dy = p.y - height / 2;
                    const angle = Math.atan2(dy, dx);
                    const force = Math.random() * 6 + 3;
                    
                    p.vx = Math.cos(angle) * force + (Math.random() - 0.5) * 2;
                    p.vy = Math.sin(angle) * force + (Math.random() - 0.5) * 2;
                }
            });
            
            // Show UI elements
            document.getElementById('controls').classList.add('fade-in');
            document.getElementById('top-msg').classList.add('fade-in');
            const settingsPanel = document.getElementById('settings-panel');
            settingsPanel.classList.remove('hidden');
            settingsPanel.classList.add('fade-in');
            settingsPanel.classList.add('visible');
            return;
        }
    }
    
    if (!state.gameStarted) return;
    
    // Burst text if it hasn't been burst yet
    if (!state.textBurst) {
        state.textBurst = true;
        createShockwave(e.clientX, e.clientY, 2.5); // Strong burst to scatter particles
    } else {
        createShockwave(e.clientX, e.clientY, 1.0);
    }
});

/**
 * UI CONTROLS
 */
function initGame() {
    // Phase 1: Start with clean black screen
    state.tapCount = 0;
    state.heartForming = false;
    state.heartFormed = false;
    state.textForming = false;
    state.textFormed = false;
    state.textBurst = false;
    state.gameStarted = false;
    state.heartParticleIndices = [];
    state.textParticleIndices = [];
    state.particlesCirculating = false;
    state.circulationAngle = 0;
    state.textBounds = null;
    
    // Hide all UI elements initially
    document.getElementById('controls').classList.remove('fade-in');
    document.getElementById('controls').classList.add('hidden');
    document.getElementById('top-msg').classList.remove('fade-in');
    document.getElementById('top-msg').classList.add('hidden');
    document.getElementById('settings-panel').classList.remove('fade-in', 'visible');
    document.getElementById('settings-panel').classList.add('hidden');
    document.getElementById('performance').classList.remove('visible');
    document.getElementById('performance').classList.add('hidden');
    
    // Show tap instruction
    const tapInstruction = document.getElementById('tap-instruction');
    if (tapInstruction) {
        tapInstruction.style.opacity = '0.5';
    }
    
    // Initialize particle count display (for when settings become available)
    const slider = document.getElementById('particle-slider');
    if (slider) {
        slider.min = config.minParticleCount;
        slider.max = config.maxParticleCount;
        slider.value = config.particleCount;
    }
    const particleCountDisplay = document.getElementById('particle-count-display');
    if (particleCountDisplay) {
        particleCountDisplay.textContent = config.particleCount;
    }
    
    // Particles start in random positions (not formed into shapes yet)
    // formParticlesIntoTextAndHeart() will be called when tapCount reaches 1
}

function toggleMode() {
    state.gravityMode *= -1;
    const btn = document.getElementById('btn-mode');
    const label = document.getElementById('mode-label');
    
    if (state.gravityMode === 1) {
        btn.classList.replace('mode-repel', 'mode-attract');
        label.innerText = "GRAVITY";
    } else {
        btn.classList.replace('mode-attract', 'mode-repel');
        label.innerText = "REPEL";
    }
    
    // Feedback shockwave
    createShockwave(state.mouseX, state.mouseY, 0.5);
    
    // Haptic feedback if available
    if (navigator.vibrate) navigator.vibrate(50);
}

function setSlow(active) {
    state.isSlowMo = active;
    const btn = document.getElementById('btn-slow');
    if(active) {
        btn.classList.add('active');
        if (navigator.vibrate) navigator.vibrate(20);
    } else {
        btn.classList.remove('active');
    }
}

/**
 * COLOR SCHEMES
 */
const colorSchemes = {
    neon: { baseHue: 200, saturation: 100, lightness: 55, hueRange: 60 },
    fire: { baseHue: 15, saturation: 100, lightness: 60, hueRange: 40 },
    ocean: { baseHue: 180, saturation: 95, lightness: 55, hueRange: 50 },
    purple: { baseHue: 270, saturation: 95, lightness: 60, hueRange: 50 },
    pink: { baseHue: 320, saturation: 100, lightness: 65, hueRange: 40 },
    cyan: { baseHue: 190, saturation: 100, lightness: 55, hueRange: 60 }
};

function setColorScheme(scheme) {
    state.colorScheme = scheme;
    state.hue = colorSchemes[scheme].baseHue;
    
    // Update particle hue offsets to match new scheme for immediate vibrant color change
    const newScheme = colorSchemes[scheme];
    particles.forEach(p => {
        p.hueOffset = (Math.random() - 0.5) * newScheme.hueRange;
    });
    
    // Update UI
    document.querySelectorAll('.color-scheme-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.getAttribute('data-scheme') === scheme) {
            btn.classList.add('active');
        }
    });
    
    if (navigator.vibrate) navigator.vibrate(30);
}

/**
 * SETTINGS PANEL
 */
function toggleSettings() {
    const panel = document.getElementById('settings-panel');
    const menu = document.getElementById('settings-menu');
    
    if (panel.classList.contains('visible')) {
        menu.classList.remove('visible');
        setTimeout(() => panel.classList.remove('visible'), 300);
    } else {
        panel.classList.add('visible');
        setTimeout(() => menu.classList.add('visible'), 50);
    }
    
    if (navigator.vibrate) navigator.vibrate(20);
}

function updateParticleCount(value) {
    let newCount = parseInt(value);
    // Clamp to min/max limits
    newCount = Math.max(config.minParticleCount, Math.min(config.maxParticleCount, newCount));
    config.particleCount = newCount;
    document.getElementById('particle-count-display').textContent = newCount;
    
    // Resize particle array
    const currentCount = particles.length;
    if (newCount > currentCount) {
        for (let i = currentCount; i < newCount; i++) {
            particles.push(new Particle());
        }
    } else if (newCount < currentCount) {
        particles.length = newCount;
    }
    
    // Reset adaptive quality counters when manually adjusted
    state.consecutiveLowFPS = 0;
    state.consecutiveHighFPS = 0;
    
    if (navigator.vibrate) navigator.vibrate(10);
}

function togglePerformance(enabled) {
    state.showPerformance = enabled;
    const perfEl = document.getElementById('performance');
    if (enabled) {
        perfEl.classList.add('visible');
    } else {
        perfEl.classList.remove('visible');
    }
}

/**
 * PRESET PATTERNS
 */
function applyPattern(pattern) {
    const centerX = width / 2;
    const centerY = height / 2;
    
    particles.forEach((p, i) => {
        const angle = (i / particles.length) * Math.PI * 2;
        const radius = Math.min(width, height) * 0.3;
        
        switch(pattern) {
            case 'vortex':
                p.x = centerX + Math.cos(angle) * radius;
                p.y = centerY + Math.sin(angle) * radius;
                p.vx = -Math.sin(angle) * 2;
                p.vy = Math.cos(angle) * 2;
                break;
                
            case 'spiral':
                const spiralRadius = radius * (i / particles.length);
                const spiralAngle = angle + (i * 0.1);
                p.x = centerX + Math.cos(spiralAngle) * spiralRadius;
                p.y = centerY + Math.sin(spiralAngle) * spiralRadius;
                p.vx = -Math.sin(spiralAngle) * 1.5;
                p.vy = Math.cos(spiralAngle) * 1.5;
                break;
                
            case 'explosion':
                p.x = centerX;
                p.y = centerY;
                p.vx = Math.cos(angle) * (Math.random() * 8 + 4);
                p.vy = Math.sin(angle) * (Math.random() * 8 + 4);
                break;
                
            case 'orbit':
                p.x = centerX + Math.cos(angle) * radius;
                p.y = centerY + Math.sin(angle) * radius;
                p.vx = -Math.sin(angle) * 1;
                p.vy = Math.cos(angle) * 1;
                break;
                
            case 'wave':
                p.x = (i / particles.length) * width;
                p.y = centerY + Math.sin(angle * 3) * (height * 0.2);
                p.vx = 0;
                p.vy = Math.cos(angle * 3) * 2;
                break;
        }
    });
    
    createShockwave(centerX, centerY, 0.3);
    if (navigator.vibrate) navigator.vibrate(40);
}

/**
 * PARTICLE ENGINE
 */
class Particle {
    constructor() {
        this.reset(true);
    }

    reset(randomStart = false) {
        if (randomStart) {
            // Start particles off-screen or well distributed to avoid visual glitches on load
            // Random positions but ensure they're not clustered visibly
            this.x = Math.random() * width;
            this.y = Math.random() * height;
        } else {
            // Spawn closer to center on mobile to keep action on screen
            this.x = (Math.random() * width);
            this.y = Math.random() > 0.5 ? 0 : height;
        }
        
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = (Math.random() - 0.5) * 2;
        // Optimized particle sizes: cleaner, more uniform on mobile; refined on desktop
        this.size = isMobile ? (Math.random() * 2.2 + 1.8) : (Math.random() * 2.0 + 1.3);
        // Increased hue offset range for more vibrant color variation
        const currentScheme = colorSchemes[state.colorScheme] || colorSchemes.neon;
        this.hueOffset = (Math.random() - 0.5) * currentScheme.hueRange;
        
        // Animation properties for phase transitions
        this.animating = false;
        this.startX = this.x;
        this.startY = this.y;
        this.targetX = this.x;
        this.targetY = this.y;
        this.isHeartParticle = false; // Track if particle is part of heart outline
        this.swirlX = this.x; // Swirl intermediate position
        this.swirlY = this.y;
        this.textX = this.x; // Text position for circulation
        this.textY = this.y;
        this.circulationRadius = 0; // Distance from text center for circulation
        this.circulationAngle = 0; // Angle offset for circulation
    }

    update() {
        // Phase 1: Heart formation animation
        if (state.heartForming && this.animating) {
            const elapsed = performance.now() - state.heartAnimationStart;
            const progress = Math.min(1, elapsed / state.heartAnimationDuration);
            
            // Slower, smoother easing for grander heart formation effect
            // Use ease-out-cubic for elegant, slower animation
            const eased = 1 - Math.pow(1 - progress, 3); // Cubic easing for smooth, grander effect
            
            // Interpolate from start position to target position
            this.x = this.startX + (this.targetX - this.startX) * eased;
            this.y = this.startY + (this.targetY - this.startY) * eased;
            this.vx = 0;
            this.vy = 0;
            
            // Animation complete
            if (progress >= 1) {
                this.animating = false;
                this.x = this.targetX;
                this.y = this.targetY;
            }
            return;
        }
        
        // Phase 2: Simple text formation animation - direct from heart to text
        const particleIndex = particles.indexOf(this);
        if (state.textForming && this.animating && state.textParticleIndices.includes(particleIndex)) {
            const elapsed = performance.now() - state.textAnimationStart;
            const progress = Math.min(1, elapsed / state.textAnimationDuration);
            
            // Smooth easing for simple, elegant transition
            const eased = 1 - Math.pow(1 - progress, 2); // Ease-out-quad
            
            // Simple direct animation from heart to text
            this.x = this.startX + (this.targetX - this.startX) * eased;
            this.y = this.startY + (this.targetY - this.startY) * eased;
            this.vx = 0;
            this.vy = 0;
            
            // Animation complete
            if (progress >= 1) {
                this.animating = false;
                this.x = this.targetX;
                this.y = this.targetY;
            }
            return;
        }
        
        // Keep heart particles locked in place during text formation
        if (this.isHeartParticle && (state.textForming || (state.textFormed && !state.textBurst))) {
            return; // Heart particles stay at their heart positions
        }
        
        // Text formed but not burst yet - keep text particles locked
        if (state.textFormed && !state.textBurst && state.tapCount === 2) {
            return; // Text particles stay at their text positions
        }
        
        // Heart formed but text not yet formed - keep particles locked
        if (state.heartFormed && !state.textForming && !state.textFormed && !state.textBurst && state.tapCount < 3) {
            return; // Particles stay at their positions (heart or near heart)
        }

        let targetX = state.mouseX;
        let targetY = state.mouseY;

        // Idle Animation
        if (!state.gameStarted) {
            state.autoTimer += 0.00005;
            const t = Date.now() * 0.0008;
            targetX = width/2 + Math.cos(t) * (width/3.5);
            targetY = height/2 + Math.sin(t * 1.5) * (height/4);
        }

        const dx = targetX - this.x;
        const dy = targetY - this.y;
        
        // Optimized distance squared calculation with clamping
        let distSq = dx*dx + dy*dy;
        // Clamp to avoid division by zero and limit max force
        distSq = distSq < 1000 ? 1000 : (distSq > 400000 ? 400000 : distSq);

        // Cached calculations for better performance
        const timeScale = state.isSlowMo ? 0.15 : 1.0;
        const force = (config.gravityStrength * state.gravityMode * 800) / distSq;
        const forceX = dx * force * timeScale;
        const forceY = dy * force * timeScale;

        // Apply forces
        this.vx += forceX;
        this.vy += forceY;

        // Apply friction
        this.vx *= config.friction;
        this.vy *= config.friction;

        // Update position
        const moveX = this.vx * timeScale;
        const moveY = this.vy * timeScale;
        this.x += moveX;
        this.y += moveY;

        // Optimized wrap around
        if (this.x < 0) this.x = width;
        else if (this.x > width) this.x = 0;
        if (this.y < 0) this.y = height;
        else if (this.y > height) this.y = 0;
    }

    draw() {
        // Phase 1: Particles invisible before first tap
        if (state.tapCount === 0 && !state.heartForming) {
            return; // Don't draw particles until heart formation starts
        }
        
        // Elegant white luminescent glow for heart particles and text particles (Phase 1 & 2)
        if (state.heartForming || state.textForming || 
            (state.heartFormed && !state.textBurst && state.tapCount < 3) ||
            (state.textFormed && !state.textBurst && state.tapCount === 2)) {
            
            // Enhanced HD glow effect - optimized for mobile (cleaner, prettier) and desktop (crisp)
            const glowBlur = isMobile ? 20 : 26; // Refined glow values for cleaner look
            const glowIntensity = isMobile ? 0.88 : 0.82; // Optimized intensity
            const glowRadius = isMobile ? 1.15 : 1.25; // Slightly tighter glow on mobile
            const coreSize = isMobile ? 0.92 : 0.87; // Larger core on mobile for better visibility
            
            // Refined ethereal glow effect - soft outer glow with bright core
            ctx.shadowBlur = glowBlur;
            ctx.shadowColor = `rgba(255, 255, 255, ${glowIntensity})`;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size * glowRadius, 0, 6.283185307179586);
            ctx.fill();
            
            // Bright core for clarity and HD crispness
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'rgba(255, 255, 255, 1)';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size * coreSize, 0, 6.283185307179586);
            ctx.fill();
            return;
        }

        // Normal vibrant color rendering when burst
        // Optimized speed calculation
        const speed = Math.abs(this.vx) + Math.abs(this.vy);
        const scheme = colorSchemes[state.colorScheme];
        
        // Enhanced vibrant color calculation - increased multipliers for more intense colors
        // Speed-based hue shift creates more dynamic, vibrant color transitions
        const hueShift = speed * 12; // Increased from 8 for more vibrant color changes
        const hue = (state.hue + this.hueOffset + hueShift) % 360;
        
        // Boost saturation based on speed for more intense fast particles
        const baseSaturation = scheme.saturation;
        const speedSaturationBoost = Math.min(10, speed * 0.8); // Up to 10% saturation boost
        const saturation = Math.min(100, baseSaturation + speedSaturationBoost);
        
        // Enhanced lightness range - brighter colors with speed boost
        const baseLightness = scheme.lightness;
        const speedLightBoost = speed * 8; // Increased from 5 for brighter, more vibrant particles
        const light = Math.min(85, baseLightness + speedLightBoost); // Cap at 85% for intensity
        
        // Optimized HSL string - removed spaces, use bitwise OR for integer conversion
        ctx.fillStyle = `hsl(${hue|0},${saturation|0}%,${light|0}%)`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, 6.283185307179586); // 2*PI pre-calculated
        ctx.fill();
    }
}

const particles = [];

function initParticles() {
    particles.length = 0;
    for (let i = 0; i < config.particleCount; i++) {
        particles.push(new Particle());
    }
    // Phase 1: Particles start in random positions, not formed into shapes yet
    // Heart formation will be triggered on first tap
}

/**
 * Start heart formation animation (Phase 1)
 */
function startHeartFormation() {
    if (state.tapCount !== 0 || state.heartForming || state.heartFormed) return;
    
    state.heartForming = true;
    state.heartAnimationStart = performance.now();
    
    // Calculate heart size - optimized for Phase 2 text space (30-32% of screen, smaller and more elegant)
    const centerX = width / 2;
    // Position heart slightly higher to leave room for text below in Phase 2
    const centerY = height / 2 - (isMobile ? height * 0.08 : height * 0.1);
    const heartSize = Math.min(width, height) * (isMobile ? 0.30 : 0.32); // Smaller, more elegant size
    const heartPoints = generateHeartOutline(centerX, centerY, heartSize);
    
    if (heartPoints.length === 0) return;
    
    // Store current positions as start positions for animation
    particles.forEach(p => {
        p.startX = p.x;
        p.startY = p.y;
    });
    
    // Distribute particles to heart with depth/filling for grander effect
    // Use ~70% for outline, ~30% for interior filling
    state.heartParticleIndices = [];
    const outlineParticleCount = Math.floor(particles.length * 0.7);
    const interiorParticleCount = particles.length - outlineParticleCount;
    
    // Fill heart outline with particles
    const step = Math.max(1, Math.floor(heartPoints.length / outlineParticleCount));
    for (let i = 0; i < outlineParticleCount; i++) {
        const p = particles[i];
        const pointIndex = (i * step) % heartPoints.length;
        const point = heartPoints[pointIndex];
        p.targetX = point.x;
        p.targetY = point.y;
        p.animating = true;
        p.vx = 0;
        p.vy = 0;
        p.isHeartParticle = true;
        state.heartParticleIndices.push(i);
    }
    
    // Fill heart interior with remaining particles for depth
    for (let i = outlineParticleCount; i < particles.length; i++) {
        const p = particles[i];
        // Random positions inside heart (approximate interior)
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * heartSize * 0.4; // Interior radius
        p.targetX = centerX + Math.cos(angle) * radius;
        p.targetY = centerY + Math.sin(angle) * radius;
        p.animating = true;
        p.vx = 0;
        p.vy = 0;
        p.isHeartParticle = true;
        state.heartParticleIndices.push(i);
    }
    
    // Hide tap instruction
    const tapInstruction = document.getElementById('tap-instruction');
    if (tapInstruction) {
        tapInstruction.style.opacity = '0';
    }
    
    // Check for animation completion after duration
    setTimeout(() => {
        state.heartForming = false;
        state.heartFormed = true;
        state.tapCount = 1;
        // Lock all particles at target positions
        particles.forEach(p => {
            p.x = p.targetX;
            p.y = p.targetY;
            p.animating = false;
        });
        
        // Show "tap again" instruction for Phase 2 - centered in heart
        const tapAgainInstruction = document.getElementById('tap-again-instruction');
        if (tapAgainInstruction) {
            // Position instruction at heart center (same as heart centerY)
            const heartCenterY = height / 2 - (isMobile ? height * 0.08 : height * 0.1);
            tapAgainInstruction.style.top = heartCenterY + 'px';
            setTimeout(() => {
                tapAgainInstruction.style.opacity = '0.5';
            }, 300); // Small delay for smooth transition
        }
    }, state.heartAnimationDuration);
}

/**
 * Start text formation animation (Phase 2)
 * Simple: Particles disperse from heart directly to text positions
 */
function startTextFormation() {
    if (state.tapCount !== 1 || !state.heartFormed || state.textForming || state.textFormed) return;
    
    state.textForming = true;
    state.textAnimationStart = performance.now();
    
    // Hide "tap again" instruction
    const tapAgainInstruction = document.getElementById('tap-again-instruction');
    if (tapAgainInstruction) {
        tapAgainInstruction.style.opacity = '0';
    }
    
    const text = "HAPPY\nBIRTHDAY\nHALIMA";
    const lines = text.split('\n');
    
    // Calculate responsive font size
    const baseFontSize = isMobile 
        ? Math.min(width, height) * 0.08
        : Math.min(width, height) * 0.10;
    const fontSize = baseFontSize;
    const lineHeight = fontSize * 1.3;
    
    // Create temporary canvas for text rendering
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = width;
    tempCanvas.height = height;
    const tempCtx = tempCanvas.getContext('2d');
    
    // Render text to get pixel data
    tempCtx.fillStyle = 'white';
    tempCtx.font = `600 ${fontSize}px 'Rajdhani', Arial, sans-serif`;
    tempCtx.textAlign = 'center';
    tempCtx.textBaseline = 'middle';
    
    // Calculate text block dimensions - position text below heart
    const textWidth = Math.max(...lines.map(line => tempCtx.measureText(line).width));
    const textHeight = lines.length * lineHeight;
    const centerX = width / 2;
    const heartCenterY = height / 2 - (isMobile ? height * 0.08 : height * 0.1);
    const heartSize = Math.min(width, height) * (isMobile ? 0.30 : 0.32);
    const textCenterY = heartCenterY + (heartSize * 0.5) + textHeight * 0.7;
    
    // Draw text on temp canvas
    lines.forEach((line, i) => {
        const y = textCenterY - textHeight / 2 + (i + 0.5) * lineHeight;
        tempCtx.fillText(line, centerX, y);
    });
    
    // Get pixel data
    const imageData = tempCtx.getImageData(0, 0, width, height);
    const textPixels = [];
    
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const index = (y * width + x) * 4;
            const alpha = imageData.data[index + 3];
            if (alpha > 128) {
                textPixels.push({ x, y });
            }
        }
    }
    
    if (textPixels.length === 0) {
        console.warn('No text pixels found');
        return;
    }
    
    // Auto-adjust particle count for legible, clean text
    // Optimal: ~0.35-0.4 particles per pixel for clean, readable text
    const optimalParticleCount = Math.floor(textPixels.length * (isMobile ? 0.35 : 0.4));
    const maxAvailableParticles = particles.length;
    const textParticleCount = Math.min(optimalParticleCount, maxAvailableParticles);
    
    // Select particles to use for text - use all particles (heart disperses into text)
    state.textParticleIndices = [];
    const particlesForText = [];
    
    // Use particles evenly distributed from all heart particles
    const step = Math.max(1, Math.floor(particles.length / textParticleCount));
    for (let i = 0; i < textParticleCount; i++) {
        const particleIndex = (i * step) % particles.length;
        const p = particles[particleIndex];
        particlesForText.push(p);
        state.textParticleIndices.push(particleIndex);
        p.isHeartParticle = false; // Remove from heart, will form text
    }
    
    // Store current heart positions as start positions (simple direct animation)
    particlesForText.forEach((p, i) => {
        p.startX = p.x;
        p.startY = p.y;
    });
    
    // Distribute text particles to text positions with optimal density
    const pixelStep = Math.max(1, Math.floor(textPixels.length / particlesForText.length));
    particlesForText.forEach((p, i) => {
        const pixelIndex = (i * pixelStep) % textPixels.length;
        const pixel = textPixels[pixelIndex];
        p.targetX = pixel.x;
        p.targetY = pixel.y;
        p.animating = true;
        p.vx = 0;
        p.vy = 0;
    });
    
    // Calculate text bounds for click detection
    const textBounds = {
        minX: Math.min(...textPixels.map(p => p.x)),
        maxX: Math.max(...textPixels.map(p => p.x)),
        minY: Math.min(...textPixels.map(p => p.y)),
        maxY: Math.max(...textPixels.map(p => p.y)),
        centerX: centerX,
        centerY: textCenterY
    };
    
    // Store text bounds for click detection
    state.textBounds = textBounds;
    
    // Check for animation completion after duration
    setTimeout(() => {
        state.textForming = false;
        state.textFormed = true;
        state.tapCount = 2;
        
        // Lock text particles at target positions
        particlesForText.forEach(p => {
            p.x = p.targetX;
            p.y = p.targetY;
            p.animating = false;
            p.textX = p.x; // Store text position
            p.textY = p.y;
        });
    }, state.textAnimationDuration);
}

/**
 * Generate refined heart shape outline positions (Hollow Knight SOUL meter aesthetic)
 */
function generateHeartOutline(centerX, centerY, size) {
    const points = [];
    // More points for smoother curve - optimized for HD rendering
    const steps = isMobile ? 120 : 160; // More points on desktop for crisper outline
    
    for (let i = 0; i <= steps; i++) {
        const t = (i / steps) * Math.PI * 2;
        // Mathematical heart curve formula
        const x = 16 * Math.pow(Math.sin(t), 3);
        const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
        
        // Scale with refined proportions (more compact, elegant)
        const scale = size / 16;
        points.push({
            x: centerX + (x * scale),
            y: centerY + (y * scale)
        });
    }
    
    return points;
}

/**
 * Form particles into text and heart shape
 */
function formParticlesIntoTextAndHeart() {
    if (particles.length === 0) return;
    
    const text = "HAPPY\nBIRTHDAY\nHALIMA";
    const lines = text.split('\n');
    
    // Calculate responsive font size (smaller, more refined proportions)
    const baseFontSize = isMobile 
        ? Math.min(width, height) * 0.08  // Smaller on mobile for better fit
        : Math.min(width, height) * 0.10; // Refined size on desktop
    const fontSize = baseFontSize;
    const lineHeight = fontSize * 1.3; // Tighter line spacing for elegance
    
    // Create temporary canvas for text rendering
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = width;
    tempCanvas.height = height;
    const tempCtx = tempCanvas.getContext('2d');
    
    // Render text to get pixel data (elegant, refined styling)
    tempCtx.fillStyle = 'white';
    tempCtx.font = `600 ${fontSize}px 'Rajdhani', Arial, sans-serif`; // Use project font, slightly less bold
    tempCtx.textAlign = 'center';
    tempCtx.textBaseline = 'middle';
    
    // Calculate text block dimensions
    const textWidth = Math.max(...lines.map(line => tempCtx.measureText(line).width));
    const textHeight = lines.length * lineHeight;
    const centerX = width / 2;
    const centerY = height / 2;
    
    // Draw text on temp canvas
    lines.forEach((line, i) => {
        const y = centerY - textHeight / 2 + (i + 0.5) * lineHeight;
        tempCtx.fillText(line, centerX, y);
    });
    
    // Get pixel data
    const imageData = tempCtx.getImageData(0, 0, width, height);
    const textPixels = [];
    
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const index = (y * width + x) * 4;
            const alpha = imageData.data[index + 3];
            if (alpha > 128) { // Pixel is part of text
                textPixels.push({ x, y });
            }
        }
    }
    
    // Calculate refined heart size (smaller, more elegant proportions like SOUL meter)
    // Heart should snugly fit around text with refined padding
    const padding = Math.max(textWidth, textHeight) * 0.25; // Refined padding
    const heartSize = Math.max(textWidth, textHeight) + padding;
    const heartPoints = generateHeartOutline(centerX, centerY, heartSize);
    
    // Distribute particles: 80% for text (denser), 20% for heart outline (thinner, more elegant)
    const textParticleCount = Math.floor(particles.length * 0.80);
    const heartParticleCount = particles.length - textParticleCount;
    
    // Assign text positions
    if (textPixels.length > 0) {
        const step = Math.max(1, Math.floor(textPixels.length / textParticleCount));
        for (let i = 0; i < textParticleCount && i < particles.length; i++) {
            const pixelIndex = (i * step) % textPixels.length;
            const pixel = textPixels[pixelIndex];
            particles[i].x = pixel.x;
            particles[i].y = pixel.y;
            particles[i].vx = 0;
            particles[i].vy = 0;
        }
    }
    
    // Assign heart outline positions
    if (heartPoints.length > 0 && heartParticleCount > 0) {
        const step = Math.max(1, Math.floor(heartPoints.length / heartParticleCount));
        for (let i = 0; i < heartParticleCount; i++) {
            const particleIndex = textParticleCount + i;
            if (particleIndex < particles.length) {
                const pointIndex = (i * step) % heartPoints.length;
                const point = heartPoints[pointIndex];
                particles[particleIndex].x = point.x;
                particles[particleIndex].y = point.y;
                particles[particleIndex].vx = 0;
                particles[particleIndex].vy = 0;
                // Heart particles slightly larger for elegant outline visibility (like SOUL meter border)
                particles[particleIndex].size = particles[particleIndex].size * 1.15; // More subtle increase
            }
        }
    }
}

function createShockwave(x, y, multiplier) {
    particles.forEach(p => {
        const dx = p.x - x;
        const dy = p.y - y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const maxDist = 500 * multiplier;
        
        if (dist < maxDist) {
            const force = (maxDist - dist) / maxDist; // 0.0 to 1.0
            const angle = Math.atan2(dy, dx);
            const strength = config.shockwaveForce * force * multiplier;
            
            p.vx += Math.cos(angle) * strength;
            p.vy += Math.sin(angle) * strength;
        }
    });
}

/**
 * ADAPTIVE QUALITY SYSTEM
 */
function adjustQuality() {
    if (!config.adaptiveQuality) return;
    
    if (state.fps < 50) {
        state.consecutiveLowFPS++;
        state.consecutiveHighFPS = 0;
        
        if (state.consecutiveLowFPS >= 3 && config.particleCount > config.minParticleCount) {
            const reduction = Math.max(50, Math.floor(config.particleCount * 0.1));
            config.particleCount = Math.max(config.minParticleCount, config.particleCount - reduction);
            
            // Resize particle array
            if (particles.length > config.particleCount) {
                particles.length = config.particleCount;
            }
            state.consecutiveLowFPS = 0;
        }
    } else if (state.fps >= 58) {
        state.consecutiveHighFPS++;
        state.consecutiveLowFPS = 0;
        
        if (state.consecutiveHighFPS >= 5 && config.particleCount < config.maxParticleCount) {
            const increase = Math.min(50, Math.floor((config.maxParticleCount - config.particleCount) * 0.1));
            config.particleCount = Math.min(config.maxParticleCount, config.particleCount + increase);
            
            // Add particles if needed
            while (particles.length < config.particleCount) {
                particles.push(new Particle());
            }
            state.consecutiveHighFPS = 0;
        }
    }
}

/**
 * RENDER LOOP
 */
function loop() {
    const now = performance.now();
    state.frameDelta = now - state.lastFrameTime;
    
    // Frame rate limiting - only render if enough time has passed
    if (state.frameDelta >= state.targetFrameTime) {
        state.lastFrameTime = now - (state.frameDelta % state.targetFrameTime);
        
        // Update performance metrics
        state.frameCount++;
        if (now - state.lastTime >= 1000) {
            state.fps = state.frameCount;
            state.frameCount = 0;
            state.lastTime = now;
            
            // Adaptive quality adjustment
            adjustQuality();
            
            if (state.showPerformance) {
                document.getElementById('fps').textContent = state.fps;
                document.getElementById('particle-count').textContent = particles.length;
            }
        }
        
        // Trail effect - optimized for mobile and desktop
        // Only apply trail if particles are visible (after first tap)
        if (state.tapCount > 0 || state.heartForming) {
            ctx.fillStyle = `rgba(0, 0, 0, ${config.trailLength})`;
            ctx.fillRect(0, 0, width, height);
        } else {
            // Clear canvas completely before first tap for clean black screen
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.fillRect(0, 0, width, height);
        }

        ctx.globalCompositeOperation = 'lighter';
        
        state.hue += config.colorSpeed;

        // Update and draw particles
        for(let i = 0; i < particles.length; i++) {
            particles[i].update();
            particles[i].draw();
        }

        ctx.globalCompositeOperation = 'source-over';
    }
    
    requestAnimationFrame(loop);
}

// Start
initParticles();
initGame(); // Auto-start game without splash screen
loop();

// Prevent standard iOS gestures
document.addEventListener('gesturestart', function (e) {
    e.preventDefault();
});

</script>
</body>
</html>
